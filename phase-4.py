"""Phase 4 — Allocation & Position Sizing

Implements:
- Phase 4A: weight definition from expectancy
- Phase 4B: basket risk budget and per-stock loss caps
- Phase 4C: stop/target price levels (R-based)
- Phase 4D: quantity calculation (risk-based & capital-cap)
- Phase 4E: portfolio scaling if total capital > C

Functions:
- `allocate_positions` — main entry point. Works with dicts/lists.

Author: generated by assistant
"""
from typing import Dict, List, Tuple, Any, Optional
import math
import argparse
import pandas as pd
import os


def allocate_positions(
	symbols: List[str],
	expectancies: List[float],
	entry_prices: List[float],
	C: float,
	L_percent: float,
	c_percent: float,
	s_percent: float,
	R: float,
	min_notional: float = 5000.0,
) -> List[Dict[str, Any]]:
	"""Allocate quantities per symbol according to Phase 4.

	Args:
		symbols: list of tickers
		expectancies: historical expectancy (si) for each symbol
		entry_prices: current entry price Ei for each symbol
		C: total capital available (₹)
		L_percent: basket risk limit (e.g. 0.02 for 2%)
		c_percent: per-stock capital cap (e.g. 0.03 for 3%)
		s_percent: stop distance as fraction (e.g. 0.02 for 2%)
		R: target multiple of risk (e.g. 2 for 2x)
		min_notional: minimum position notional to accept (₹)

	Returns:
		list of dicts with allocation details per symbol
	"""

	n = len(symbols)
	if not (len(expectancies) == n and len(entry_prices) == n):
		raise ValueError("symbols, expectancies and entry_prices must have same length")

	# Phase 4A: s_i^+ and weights
	s_pos = [max(0.0, float(si)) for si in expectancies]
	total_s_pos = sum(s_pos)
	if total_s_pos <= 0:
		# no positive expectancy -> return zeros
		return [
			{
				"symbol": sym,
				"expectancy": si,
				"entry": ei,
				"weight": 0.0,
				"loss_cap": 0.0,
				"stop": None,
				"risk_per_share": None,
				"target": None,
				"qi_raw": 0,
				"qi_cap": 0,
				"qi": 0,
				"value": 0.0,
			}
			for sym, si, ei in zip(symbols, expectancies, entry_prices)
		]

	weights = [s / total_s_pos for s in s_pos]

	# Phase 4B: basket loss budget and per-stock loss caps
	Lcap = C * float(L_percent)
	loss_caps = [Lcap * w for w in weights]

	rows: List[Dict[str, Any]] = []
	C_cap_per_stock = C * float(c_percent)

	# Phase 4C and 4D: stops, risk per share, raw and cap quantities
	for sym, si, ei, w, loss_cap in zip(symbols, expectancies, entry_prices, weights, loss_caps):
		Ei = float(ei)
		# Stop (long): Si = Ei * (1 - s%)
		Si = Ei * (1.0 - float(s_percent))
		# Risk per share: Ri = Ei - Si = Ei * s%
		Ri = Ei * float(s_percent)
		# Target: Ti = Ei + R * Ri
		Ti = Ei + float(R) * Ri

		# Risk-based raw quantity
		if Ri <= 0:
			qi_raw = 0
		else:
			qi_raw = math.floor(loss_cap / Ri)

		# Capital cap limited quantity
		if Ei <= 0:
			qi_cap = 0
		else:
			qi_cap = math.floor(C_cap_per_stock / Ei)

		qi = int(min(qi_raw, qi_cap))

		# Sanity check: reject tiny positions
		value = qi * Ei
		if value < float(min_notional):
			qi = 0
			value = 0.0

		rows.append(
			{
				"symbol": sym,
				"expectancy": float(si),
				"weight": w,
				"entry": Ei,
				"stop": Si,
				"risk_per_share": Ri,
				"target": Ti,
				"loss_cap": loss_cap,
				"qi_raw": qi_raw,
				"qi_cap": qi_cap,
				"qi": qi,
				"value": value,
			}
		)

	# Phase 4E: Portfolio scaling if over-allocated
	total_value = sum(r["value"] for r in rows)
	if total_value > C and total_value > 0:
		alpha = float(C) / float(total_value)
		for r in rows:
			scaled_q = math.floor(alpha * r["qi"]) if r["qi"] > 0 else 0
			r["qi_final"] = int(scaled_q)
			r["value_final"] = r["qi_final"] * r["entry"]
			# reapply min_notional rule after scaling
			if r["value_final"] < float(min_notional):
				r["qi_final"] = 0
				r["value_final"] = 0.0
	else:
		for r in rows:
			r["qi_final"] = int(r["qi"])
			r["value_final"] = r["value"]

	return rows


if __name__ == "__main__":
	parser = argparse.ArgumentParser(description="Phase 4 allocation using Phase-3.xlsx as input")
	parser.add_argument("--input", "-i", default=os.path.join("phase-3results", "Phase-3.xlsx"), help="Path to Phase-3 Excel file")
	parser.add_argument("--symbol-col", default="Stock", help="Column name for symbol/ticker")
	parser.add_argument("--entry-col", default="Entry Price (₹)", help="Column name for entry price")
	parser.add_argument("--expectancy-col", default=None, help="Column name for expectancy values (if omitted, script will try common alternatives)")
	parser.add_argument("--capital", "-C", type=float, default=100000.0, help="Total capital C in ₹")
	parser.add_argument("--basket-risk", type=float, default=0.02, help="Basket risk L% as decimal (e.g. 0.02)")
	parser.add_argument("--cap-per-stock", type=float, default=0.03, help="Per-stock capital cap c% as decimal (e.g. 0.03)")
	parser.add_argument("--stop-pct", type=float, default=0.02, help="Stop percentage s% as decimal (e.g. 0.02)")
	parser.add_argument("--R", type=float, default=2.0, help="Target multiple of risk")
	parser.add_argument("--min-notional", type=float, default=5000.0, help="Minimum notional per position to accept")
	parser.add_argument("--output", "-o", default=os.path.join("phase-4results", "allocations.xlsx"), help="Output Excel path to write allocations")

	args = parser.parse_args()

	# Load Excel
	df = pd.read_excel(args.input)

	# Heuristics to pick expectancy column if not provided
	expect_col = args.expectancy_col
	if expect_col is None:
		candidates = ["Expectancy", "expectancy", "Expectancy (s)", "Relative Strength %", "Relative Strength", "Risk %", "Risk%", "Relative Strength"]
		for c in candidates:
			if c in df.columns:
				expect_col = c
				break

	if expect_col is None:
		# fallback: create small positive score from Relative Strength % if present, else use 1 for all
		if "Relative Strength %" in df.columns:
			expect_col = "Relative Strength %"
		else:
			df["__expectancy_fallback__"] = 1.0
			expect_col = "__expectancy_fallback__"

	# Extract required arrays
	symbols = df[args.symbol_col].astype(str).tolist()
	entry_prices = df[args.entry_col].astype(float).tolist()

	# Try convert expectancy to numeric, coerce errors to 0
	expectancies = pd.to_numeric(df[expect_col], errors="coerce").fillna(0.0).astype(float).tolist()

	alloc = allocate_positions(
		symbols,
		expectancies,
		entry_prices,
		args.capital,
		args.basket_risk,
		args.cap_per_stock,
		args.stop_pct,
		args.R,
		args.min_notional,
	)

	# Print allocations in a readable way
	for r in alloc:
		print(r)

	# Export results to Excel (and CSV alongside)
	out_path = args.output
	out_dir = os.path.dirname(out_path)
	if out_dir and not os.path.exists(out_dir):
		os.makedirs(out_dir, exist_ok=True)

	# Build DataFrame
	df_out = pd.DataFrame(alloc)
	# Prefer a readable column order if available
	cols = [
		"symbol",
		"expectancy",
		"weight",
		"entry",
		"stop",
		"risk_per_share",
		"target",
		"loss_cap",
		"qi_raw",
		"qi_cap",
		"qi",
		"value",
		"qi_final",
		"value_final",
	]
	existing_cols = [c for c in cols if c in df_out.columns]
	df_out = df_out[existing_cols + [c for c in df_out.columns if c not in existing_cols]]

	try:
		df_out.to_excel(out_path, index=False)
	except Exception:
		# fallback to CSV if Excel write fails
		csv_path = os.path.splitext(out_path)[0] + ".csv"
		df_out.to_csv(csv_path, index=False)
		out_path = csv_path

	print(f"Wrote allocations to: {out_path}")

